<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>LCP-Sim ThreeJS Viewer</title>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background: #111;
            color: #eee;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* GUI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(20, 20, 30, 0.85);
            padding: 15px;
            border-radius: 12px;
            display: flex;
            gap: 20px;
            align-items: flex-end;
            backdrop-filter: blur(5px);
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: center;
        }

        label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type=range] {
            width: 140px;
            background: #333;
            accent-color: #00d4ff;
        }

        .value-disp {
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            color: #00d4ff;
        }

        button {
            background: #444;
            border: 1px solid #555;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
        }

        button:hover {
            background: #555;
        }

        button.primary {
            background: #ff4b4b;
            border-color: #ff2b2b;
        }

        button.primary:hover {
            background: #ff2b2b;
        }

        #playback-controls {
            display: none;
            /* Hidden by default */
            width: 300px;
            text-align: center;
        }

        #status-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        #sun-marker {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: yellow;
            font-size: 12px;
        }
    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <div id="sun-marker">â˜€ Sun</div>

    <div id="status-bar">Safe</div>

    <!-- UI: Manual Mode -->
    <div id="ui-layer">
        <div id="manual-controls" style="display:flex; gap:20px;">
            <div class="control-group">
                <label>Stow Azimuth</label>
                <div class="value-disp" id="val-az">0.0Â°</div>
                <input type="range" id="rng-az" min="-180" max="180" step="1" value="0">
            </div>

            <div class="control-group">
                <label>Stow Elevation</label>
                <div class="value-disp" id="val-el">0.0Â°</div>
                <input type="range" id="rng-el" min="0" max="90" step="1" value="0">
            </div>

            <div class="control-group" style="justify-content: flex-end;">
                <button onclick="unstow()">Unstow</button>
            </div>

            <div class="control-group" style="justify-content: flex-end;">
                <button class="primary" onclick="record()">ðŸ”´ Record</button>
            </div>
        </div>

        <div id="playback-controls">
            <div class="control-group" style="width:100%">
                <label id="lbl-time">Playback</label>
                <input type="range" id="rng-play" min="0" max="100" value="0" style="width:100%">
                <div style="display:flex; justify-content:center; gap:10px; margin-top:5px;">
                    <button onclick="togglePlay()" id="btn-play">â–¶ Play</button>
                    <button onclick="stopPlay()">Stop</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Streamlit Boilerplate ---
        function sendMessageToStreamlitClient(type, data) {
            const out = { type: type, ...data };
            window.parent.postMessage(out, "*");
        }

        function setComponentValue(value) {
            sendMessageToStreamlitClient("streamlit:setComponentValue", { value: value });
        }

        function onStreamlitReady() {
            // Adjust frame height automatically?
            // Actually usually we just set standard height on init.
            sendMessageToStreamlitClient("streamlit:componentReady", { apiVersion: 1 });
        }

        // 1. Signal Ready immediately to avoid timeout
        onStreamlitReady();

        // --- THREE.JS GLOBALS ---
        let scene, camera, renderer, controls, panelsMesh, frameMesh;
        let instancedMesh;
        let dummy = new THREE.Object3D();

        // Data
        let geoData = null;
        let sceneState = null;
        let frames = null; // Animation frames
        let isPlayback = false;
        let isPlaying = false;
        let playIdx = 0;
        let animationId = null;

        const PLANT_ROTATION_DEG = 5.0; // Hardcoded default, can be passed

        // --- INITIALIZATION ---
        function init() {
            if (!window.THREE) {
                console.error("ThreeJS not loaded");
                document.getElementById('canvas-container').innerHTML = "Failed to load ThreeJS";
                return;
            }
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            // Grid
            const grid = new THREE.GridHelper(100, 100, 0x444444, 0x333333);
            scene.add(grid);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, -10, 5);
            camera.up.set(0, 0, 1);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Controls
            // Note: OrbitControls is usually in examples folder. We load it from CDN above.
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const amb = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(amb);

            const dir = new THREE.DirectionalLight(0xffffff, 1.0);
            dir.position.set(10, 10, 20);
            scene.add(dir);

            // UI Listeners
            const rAz = document.getElementById("rng-az");
            const rEl = document.getElementById("rng-el");

            rAz.addEventListener("input", (e) => {
                document.getElementById("val-az").innerText = e.target.value + "Â°";
                updatePanels();
            });
            rEl.addEventListener("input", (e) => {
                document.getElementById("val-el").innerText = e.target.value + "Â°";
                updatePanels();
            });

            const rPlay = document.getElementById("rng-play");
            rPlay.addEventListener("input", (e) => {
                playIdx = parseInt(e.target.value);
                showFrame(playIdx);
            });

            animate();

            // Listen to Streamlit Data
            window.addEventListener("message", onStreamlitMessage);
            onStreamlitReady();

            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function onStreamlitMessage(event) {
            if (event.data.type === "streamlit:render") {
                const args = event.data.args;

                // 1. Geometry Init (Once)
                if (!geoData) {
                    initGeometry(args.geometry);
                }
                geoData = args.geometry;

                // 2. Playback vs Manual
                frames = args.playback_frames;
                if (frames && frames.length > 0) {
                    setupPlaybackMode(frames);
                } else {
                    setupManualMode(args.scene_state, args.initial_stow);
                }
            }
        }

        function initGeometry(g) {
            // g = {width, length, rows, cols, pitch_x, pitch_y ...}
            // Create InstancedMesh

            // Simple Plane for Glass
            const geom = new THREE.BoxGeometry(g.width, g.length, g.thickness || 0.05);
            const mat = new THREE.MeshPhongMaterial({ color: 0x0055aa, shininess: 100 });

            const count = g.rows * g.cols;
            instancedMesh = new THREE.InstancedMesh(geom, mat, count);
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(instancedMesh);

            // We could add pivots/posts too, but for speed, let's stick to glass first.
        }

        function setupManualMode(state, initStow) {
            isPlayback = false;
            document.getElementById("manual-controls").style.display = "flex";
            document.getElementById("playback-controls").style.display = "none";
            sceneState = state;

            // Init Sliders
            if (initStow) {
                document.getElementById("rng-az").value = initStow.az;
                document.getElementById("val-az").innerText = Math.round(initStow.az) + "Â°";
                document.getElementById("rng-el").value = initStow.el;
                document.getElementById("val-el").innerText = Math.round(initStow.el) + "Â°";
            }

            updatePanels();
        }

        function setupPlaybackMode(f) {
            isPlayback = true;
            document.getElementById("manual-controls").style.display = "none";
            document.getElementById("playback-controls").style.display = "block";

            frames = f;
            document.getElementById("rng-play").max = frames.length - 1;
            playIdx = 0;
            showFrame(0);
        }

        function updatePanels() {
            if (!instaancedMesh || !geoData) return;

            // Get Slider Vals (Manual Stow)
            const mAz = parseFloat(document.getElementById("rng-az").value);
            const mEl = parseFloat(document.getElementById("rng-el").value);

            // Get Sun (Tracking)
            // We need current sun pos. Passed via scene_state?
            // If we only have 1 static scene_state, fine.
            // sceneState = {sun_az, sun_el, plant_rotation}

            const plantRot = (sceneState && sceneState.plant_rotation) || 5.0;

            // Convert Global Sun Az to Local Tracking Az
            // T = SunAz - PlantRot
            let trackAz = 0;
            let trackEl = 0;

            if (sceneState) {
                // Simple Perfect Tracking Logic for Odd Panels
                // Ideally back-end sends this, but we want responsiveness.
                // We can replicate simple tracking: point to sun.
                trackAz = sceneState.sun_az - plantRot;
                trackEl = sceneState.sun_el; // Simple elevation tracking (backtracking is missing here)
                // For "Teach Mode", user usually cares about Stow panels. Visualizing crude tracking for others is acceptable.
            }

            // Convert Global Manual Az to Local Manual Az
            const localStowAz = mAz - plantRot;

            let idx = 0;
            const pivotHeight = geoData.offset_z || 2.0; // Pivot Z

            // Grid Layout
            // Assuming centered grid
            const offX = (geoData.cols - 1) * geoData.pitch_x / 2;
            const offY = (geoData.rows - 1) * geoData.pitch_y / 2;

            for (let r = 0; r < geoData.rows; r++) {
                for (let c = 0; c < geoData.cols; c++) {

                    const isStowGroup = ((r + c) % 2 === 0);
                    const az = isStowGroup ? localStowAz : trackAz;
                    const el = isStowGroup ? mEl : trackEl;

                    // Pos
                    const px = (c * geoData.pitch_x) - offX;
                    const py = (r * geoData.pitch_y) - offY;

                    dummy.position.set(px, py, pivotHeight);

                    // Rot
                    // ThreeJS: Y is Up? No, we set Z Up.
                    // Euler Order: Z (Azimuth) then X (Elevation)?
                    // Rotation = Azimuth around Z, Elevation around Local X (Tilt)

                    // Azimuth (0 is North/Y+). 
                    // In ThreeJS Z-up:
                    // Azimuth usually measured from North (Y).
                    // Rotation Z: -Az (CW) or +Az (CCW).
                    // Let's assume Standard Math: 0 is East (X).
                    // Convert: North (Y) -> Rotation Z +90 deg?
                    // Let's just create a Quaternion.

                    // Local Azimuth 0 = Perpendicular to Torque Tube (Y axis).
                    // So Azimuth rotates around Z.
                    // Elevation rotates around X (Torque Tube).

                    dummy.rotation.set(0, 0, 0);

                    // Apply Azimuth (Z)
                    // Convention: Positive Az = Clockwise from North?
                    // Radians.
                    const rAz = THREE.Math.degToRad(-az); // Negative for CW
                    dummy.rotateZ(rAz);

                    // Apply Elevation (X)
                    // Tilt towards sun.
                    const rEl = THREE.Math.degToRad(el); // 0 is horizontal. 90 is vertical.
                    // Depending on coordinate system, might need adjustment.
                    // Assuming "Face Up" geometry box.
                    // Rotate around X axis.
                    dummy.rotateX(rEl);

                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(idx, dummy.matrix);

                    idx++;
                }
            }

            instancedMesh.instanceMatrix.needsUpdate = true;

            // Check Clash (Basic Visualization?)
            // Not easy in JS without SAT.
            // We rely on Python for "Record" check.
            // But we can show "Checking..." label.
        }

        function showFrame(idx) {
            if (!frames || idx >= frames.length) return;
            const f = frames[idx];

            // Update Label
            document.getElementById("lbl-time").innerText = f.time_str;
            document.getElementById("rng-play").value = idx;

            // Update Scene
            // f has {az, el, sun_az, sun_el}
            // Mock sceneState
            sceneState = {
                sun_az: f.sun_az,
                sun_el: f.sun_el,
                plant_rotation: PLANT_ROTATION_DEG
            };

            // Override DOM values locally just for calculation
            // But don't change 'manual' inputs? 
            // We can just call internal update function.

            // Update logic inline for playback to avoid clashing with manual inputs
            const plantRot = PLANT_ROTATION_DEG;
            const trackAz = f.sun_az - plantRot;
            const trackEl = f.sun_el;

            const stowAz = f.az - plantRot; // Frame az is global
            const stowEl = f.el;

            updateMatrixGeneric(stowAz, stowEl, trackAz, trackEl);
        }

        function updateMatrixGeneric(stowAz, stowEl, trackAz, trackEl) {
            // ... Similar to updatePanels but explicit args ...
            // Copy-paste logic for prototype speed
            let idx = 0;
            const offX = (geoData.cols - 1) * geoData.pitch_x / 2;
            const offY = (geoData.rows - 1) * geoData.pitch_y / 2;

            for (let r = 0; r < geoData.rows; r++) {
                for (let c = 0; c < geoData.cols; c++) {
                    const isStowGroup = ((r + c) % 2 === 0);
                    const az = isStowGroup ? stowAz : trackAz;
                    const el = isStowGroup ? stowEl : trackEl;

                    const px = (c * geoData.pitch_x) - offX;
                    const py = (r * geoData.pitch_y) - offY;

                    dummy.position.set(px, py, 2.0); // Simple Z
                    dummy.rotation.set(0, 0, 0);
                    dummy.rotateZ(THREE.Math.degToRad(-az));
                    dummy.rotateX(THREE.Math.degToRad(el));
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(idx, dummy.matrix);
                    idx++;
                }
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
        }

        function record() {
            const mAz = document.getElementById("rng-az").value;
            const mEl = document.getElementById("rng-el").value;
            setComponentValue({ az: parseFloat(mAz), el: parseFloat(mEl) });
        }

        function unstow() {
            if (sceneState) {
                // Set sliders to Sun Pos
                const az = sceneState.sun_az;
                const el = sceneState.sun_el;
                document.getElementById("rng-az").value = az;
                document.getElementById("val-az").innerText = Math.round(az) + "Â°";
                document.getElementById("rng-el").value = el;
                document.getElementById("val-el").innerText = Math.round(el) + "Â°";
                updatePanels();
            }
        }

        // Playback Loop
        function togglePlay() {
            isPlaying = !isPlaying;
            const btn = document.getElementById("btn-play");
            if (isPlaying) {
                btn.innerText = "â¸ Pause";
                lastFrameTime = Date.now();
                requestAnimationFrame(playLoop);
            } else {
                btn.innerText = "â–¶ Play";
            }
        }

        function stopPlay() {
            isPlaying = false;
            playIdx = 0;
            showFrame(0);
            document.getElementById("btn-play").innerText = "â–¶ Play";
        }

        // FPS throttle
        let lastFrameTime = 0;
        const fpsInterval = 1000 / 30; // 30fps for playback loop

        function playLoop() {
            if (!isPlaying) return;

            const now = Date.now();
            const elapsed = now - lastFrameTime;

            if (elapsed > fpsInterval) {
                lastFrameTime = now - (elapsed % fpsInterval);

                playIdx++;
                if (playIdx >= frames.length) {
                    playIdx = 0; // Loop or Stop? Loop.
                }
                showFrame(playIdx);
            }

            requestAnimationFrame(playLoop);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        // Try to start immediately, or wait for load?
        // Three.js scripts are blocking (no async/defer), so they should be ready.
        init();
    </script>
</body>

</html>